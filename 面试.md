### 第一天

##### 量化

###### 不用if实现选择

```Python
# 实现c中的switch/case

def fun1(s):
    return s

def fun2():
    return 'two'

def fun3():
    return 'three'


def main():
    # 方式一：字典
    switch_set = {
        '1': fun1,
        '2': fun2,
        '3': fun3
    }
    print(switch_set['1']('hello'))
    print(switch_set['2']())

if __name__ == '__main__':
    main()
```



###### 顺序表、链表



###### sql

```sql
-- 创建数据库SRS
drop database if exists SRS;
create database SRS default charset utf8;

-- 切换到SRS
use SRS;

-- 创建学院表
create table tb_college
(
collid int not null auto_increment comment '学院编号',
-- 唯一性约束
-- collname varchar(50) not null unique(collname) comment '学院名称',
collname varchar(50) not null comment '学院名称',
collmaster varchar(20) not null comment '院长姓名',
collweb varchar(511) default '' comment '学院网站',
primary key (collid)
);

-- 添加唯一性约束(加了唯一索引)
alter table tb_college add constraint uni_college_collname unique (collname);

-- 删除唯一约束
-- alter table tb_college drop index uni_college_collname;

-- 创建学生表
create table tb_student
(
stuid int not null comment '学号',
stuname varchar(20) not null comment '学生姓名',
stusex bit default 1 comment '性别',
stubirth date not null comment '出生日期',
stuaddr varchar(255) default '' comment '籍贯',
collid int not null comment '所属学院编号',
primary key (stuid)
);

-- 添加外键约束
alter table tb_student add constraint fk_student_collid foreign key (collid) references tb_college (collid);

-- 创建教师表
create table tb_teacher
(
teacherid int not null comment '教师工号',
tname varchar(20) not null comment '教师姓名',
ttitle varchar(10) default '' comment '职称',
collid int not null comment '所属学院编号'
);

-- 添加主键约束
alter table tb_teacher add constraint pk_teacher primary key (teacherid);

-- 添加外键约束
alter table tb_teacher add constraint fk_teacher_collid foreign key (collid) references tb_college (collid);

-- 创建课程表
create table tb_course
(
courseid int not null comment '课程编号',
cname varchar(50) not null comment '课程名称',
ccredit tinyint not null comment '学分',
tid int not null comment '教师工号',
primary key (courseid)
);

-- 添加外键约束
alter table tb_course add constraint fk_course_tid foreign key (tid) references tb_teacher (teacherid);

-- 创建学生选课表
create table tb_score
(
scid int not null auto_increment comment '选课编号',
sid int not null comment '学号',
cid int not null comment '课程编号',
selectdate datetime comment '选课时间日期',
score decimal(4,1) comment '考试成绩',
primary key (scid)
);
 -- 添加检查约束(不生效，没用)
alter table tb_score add constraint ck_score_score
check (score between 0 and 100);

-- 添加外键约束
alter table tb_score add constraint fk_score_sid foreign key (sid) references tb_student (stuid);
alter table tb_score add constraint fk_score_cid foreign key (cid) references tb_course (courseid);

-- 插入数据
insert into tb_college 
(collname, collmaster, collweb) values 
('计算机学院', '左冷禅', 'http://www.abc.com'),
('外国语学院', '岳不群', 'http://www.xyz.com'),
('经济管理学院', '风清扬', 'http://www.foo.com');

insert into tb_student 
(stuid, stuname, stusex, stubirth, stuaddr, collid) values
(1001, '向问天', 1, '1990-3-4', '四川成都', 1),
(1002, '任我行', 1, '1992-2-2', '湖南长沙', 1),
(1033, '任盈盈', 0, '1989-12-3', '湖南长沙', 1),
(1572, '余沧海', 1, '1993-7-19', '四川成都', 1),
(1378, '岳灵珊', 0, '1995-8-12', '四川绵阳', 1),
(1954, '林平之', 1, '1994-9-20', '福建莆田', 1),
(2035, '令狐冲', 1, '1988-6-30', '陕西咸阳', 2),
(3011, '林震南', 1, '1985-12-12', '福建莆田', 3),
(3755, '龙傲天', 1, '1993-1-25', '广东东莞', 3),
(3923, '向天问', 0, '1985-4-17', '四川成都', 3);

insert into tb_teacher 
(teacherid, tname, ttitle, collid) values 
(1122, '张三丰', '教授', 1),
(1133, '宋远桥', '副教授', 1),
(1144, '杨逍', '副教授', 1),
(2255, '范遥', '副教授', 2),
(3366, '韦一笑', '讲师', 3);

insert into tb_course
(courseid, cname, ccredit, tid) values 
(1111, 'Python程序设计', 3, 1122),
(2222, 'Web前端开发', 2, 1122),
(3333, '操作系统', 4, 1122),
(4444, '计算机网络', 2, 1133),
(5555, '编译原理', 4, 1144),
(6666, '算法和数据结构', 3, 1144),
(7777, '经贸法语', 3, 2255),
(8888, '成本会计', 2, 3366),
(9999, '审计', 3, 3366);

-- now() - 用当前系统的时间为选课的时间
-- 最好加上要给哪些字段赋值
insert into tb_score 
(sid, cid, selectdate, score) values 
(1001, 1111, now(), 95),
(1001, 2222, now(), 87.5),
(1001, 3333, now(), 100),
(1001, 4444, now(), null),
(1001, 6666, now(), 100),
(1002, 1111, now(), 65),
(1002, 5555, now(), 42),
(1033, 1111, now(), 92.5),
(1033, 4444, now(), 78),
(1033, 5555, now(), 82.5),
(1572, 1111, now(), 78),
(1378, 1111, now(), 82),
(1378, 7777, now(), 65.5),
(2035, 7777, now(), 88),
(2035, 9999, now(), 70),
(3755, 1111, now(), 72.5),
(3755, 8888, now(), 93),
(3755, 9999, now(), null);

-- 看一张表有哪些列
desc tb_student;

-- 查询所有学生信息
select stuid, stuname, stusex, stubirth, stuaddr, collid -- 写这种
from tb_student;

-- 查询所有课程名称及学分(投影和别名)
select cname '课程名称', ccredit '学分' from tb_course;
-- or
select cname as 课程名称, ccredit as 学分 from tb_course;

-- 查询所有女学生的姓名和出生日期(筛选)
select stuname, stubirth from tb_student where stusex=0;

-- 查询所有80后学生的姓名、性别和出生日期(筛选)
select stuname,'女' as stusex, stubirth
from tb_student
where stubirth between '1980-1-1' and '1989-12-31';
and stusex=0;

-- 查询姓“林”的学生姓名和性别(模糊)
-- % - 匹配一个或多个字符
-- _ - 精确匹配一个字符
select stuname, if(stusex, '男', '女') as stusex
from tb_student
where stuname like '林%';

-- 查询姓“张”名字总共三个字的老师的姓名(模糊)
select tname from tb_teacher where tname like '张_';

-- 查询姓“张”名字总共三个字的老师的姓名和职称(模糊)
select tname,ttitle from tb_teacher where tname like '张__';

-- 查询名字中有“天”字的学生的姓名(模糊)
select stuname from tb_student where stuname like '%天%';

-- 查询学生的籍贯(不看重复的记录 - 去重)(不显示空字符串)
select distinct stuaddr from tb_student
where stuaddr<>'' and stuaddr is not null;

-- 查询男学生的姓名和生日按年龄从大到小排列(排序)
-- 生日升序
-- 默认升序
select stuname, stubirth from tb_student
where stusex=1
-- 先写筛选条件，再写排序条件
-- where stusex=1
order by stubirth asc;-- asc - 升序

-- 查询年龄最大的学生的出生日期(聚合函数)
-- min / max / sum / avg / count - 每个关系型数据库都支持的
select min(stubirth) from tb_student;
select max(stubirth) from tb_student;
-- 查询学生/男学生/女学生的总人数
select count(stuid) from tb_student;
select count(stuid) from tb_student where stusex=1;
select count(stuid) from tb_student where stusex=0;
-- 查询1111课程的平均分/最低分/最高分/选课人数/考试人数
select avg(score) from tb_score where cid=1111;
select min(score) from tb_score where cid=1111;
select count(sid) from tb_student where cid=1111;
select count(score) from tb_score where cid-1111
-- 查询年龄最小的学生的出生日期(聚合函数)


-- 查询男女学生的人数(分组和聚合函数)
select if(stusex, '男', '女') as 性别, count(stusex)
as 人数 from tb_student
group by stusex
order by 人数 desc;-- desc - 降序

-- 查询学号为1001的学生所有课程的总成绩(筛选和聚合函数)
select sum(score) as 总成绩 from tb_score where sid=1001;

-- 查询每个学生的学号和平均成绩,(分组和聚合函数)
select sid as 学号, avg(score) as 平均分
from tb_score
where score is not null
group by sid
order by 平均分 desc;

-- 查询平均成绩大于等于80分的学生的学号和平均成绩
-- 分组前的筛选 - where
-- 分组后的筛选 - having
select sid as 学号, avg(score) as 平均分
from tb_score
where score is not null  -- 去掉空值
group by sid having 平均分>=80 -- avg(score)>=80
order by 平均分 desc;

-- 查询年龄最大的学生的姓名(子查询)
-- 子查询 - 把一个查询的结构作为另一个查询的一部分来使用
select stuname from tb_student
where stubirth=(select max(stubirth) from tb_student);

-- 查询选了三门及以上的课程的学生姓名(子查询/分组条件/集合运算)
select stuname from tb_student
where stuid in -- 集合运算
(select sid from tb_score group by sid having count(sid)>=3);

-- 查询课程名称、学分、授课老师和职称
-- 笛卡尔积
select cname, ccredit, tname, ttitle
from tb_course, tb_teacher-- 笛卡尔积，全连接
where tid=teacherid;-- 自然连接

-- or
select cname, ccredit, tname, ttitle
from tb_course inner join tb_teacher
on tid=teacherid;

-- or(MySQL里无效)
select cname, ccredit, tname, ttitle
from tb_course natural join tb_teacher;

-- 学生姓名和他所在学院的名字
select stuname, collname
from tb_student, tb_college
where tb_student.collid=tb_college.collid;
-- or
select stuname, collname 
from tb_student t1, tb_college t2
where t1.collid=t2.collid;
-- or
select stuname, collname from tb_student t1
inner join tb_college t2 on t1.collid=t2.collid;

-- 查询学生姓名、课程名称、考试成绩
select stuname as 姓名, cname as 课程名称, score as 考试成绩
from tb_student t1, tb_course t2, tb_score
where stuid=sid and cid=courseid
and score is not null;-- and score<>''
-- order by 考试成绩 desc;

-- teacher
select stuname, cname, score
from tb_student
inner join tb_score on stuid=sid
inner join tb_course on courseid=cid
where score is not null;
-- 查询选课学生的姓名和平均成绩(子查询和连接查询)
explain select stuname, avg(score)
from tb_student, tb_score
where stuid=sid
group by stuname -- having avg(score)>80
order by avg(score) desc;

-- teacher1
-- SQL执行计划 - explain
explain select stuname, avgscore from tb_student, 
(select sid, avg(score) as avgscore from tb_score
group by sid) temp
where sid=stuid;

-- teacher2
select stuname, avgscore from tb_student
inner join(select sid, avg(score) as avgscore
from tb_score group by sid) temp on sid=stuid;

-- 查询每个学生的姓名和选课数量(左外连接和子查询)
select stuname, count(sid)
from tb_student, tb_score
where stuid=sid
group by stuid;

-- teacher
-- 内连接只能查到满足连表条件
-- left outer join -左外连接 - 查到左表不满足连接条件的用null表示
-- right outer join - 右外连接
-- full outer join - 全外连接 - MySQL不支持全外连接
select stuname as 学生姓名, ifnull(total, 0) as 
课程数 from tb_student
left outer join (select sid, count(sid) as total from tb_score group by sid) temp
on stuid=sid;

```

```text
1.内连接,显示两个表中有联系的所有数据;

2.左链接,以左表为参照,显示所有数据;

3.右链接,以右表为参照显示数据;
```

```sql
DROP DATABASE IF EXISTS HRS;
CREATE DATABASE HRS DEFAULT CHARSET utf8 COLLATE utf8_general_ci;

USE HRS;

CREATE TABLE TbDept 
( 
dno INT NOT NULL COMMENT '部门编号', 
dname VARCHAR ( 10 ) NOT NULL COMMENT '部门名称', 
dloc VARCHAR ( 20 ) NOT NULL COMMENT '部门所在地'
);

ALTER TABLE TbDept ADD CONSTRAINT Pk_Dept PRIMARY KEY ( dno );

INSERT INTO TbDept ( dno, dname, dloc )
VALUES
	( 10, '会计部', '北京' ),
	( 20, '研发部', '成都' ),
	( 30, '销售部', '重庆' ),
	( 40, '运维部', '深圳' );

CREATE TABLE TbEmp 
(
eno INT NOT NULL COMMENT '员工编号',
ename VARCHAR ( 20 ) NOT NULL COMMENT '员工姓名',
job VARCHAR ( 10 ) NOT NULL COMMENT '职位',
mgr INT COMMENT '直接主管编号',
sal INT NOT NULL COMMENT '月薪',
comm INT COMMENT '月补贴',
dno INT NOT NULL COMMENT '所属部门编号' 
);

ALTER TABLE TbEmp ADD CONSTRAINT Pk_Emp_Eno PRIMARY KEY ( eno );
ALTER TABLE TbEmp ADD CONSTRAINT Fk_Emp_Dno FOREIGN KEY ( dno ) REFERENCES TbDept ( dno );

INSERT INTO TbEmp ( eno, ename, job, mgr, sal, comm, dno )
VALUES
	( 7800, '张三丰', '总裁', NULL, 9000, 1800, 20 ),
	( 2056, '乔峰', '分析师', 7800, 5000, 2000, 20 ),
	( 3088, '李莫愁', '设计师', 2056, 3500, NULL, 20 ),
	( 3211, '张无忌', '程序员', 2056, 3200, NULL, 20 ),
	( 3233, '丘处机', '程序员', 2056, 3400, 800, 20 ),
	( 3251, '张翠山', '程序员', 2056, 4000, NULL, 20 ),
	( 5566, '宋远桥', '会计师', 7800, 4000, 1500, 10 ),
	( 5234, '郭靖', '出纳', 5566, 2000, 200, 10 ),
	( 3344, '黄蓉', '销售主管', 7800, 3000, 2500, 30 ),
	( 1359, '胡一刀', '销售员', 3344, 1800, NULL, 30 ),
	( 4466, '苗人凤', '销售员', 3344, 2500, NULL, 30 ),
	( 3244, '欧阳锋', '程序员', 3088, 3200, NULL, 20 ),
	( 3577, '杨过', '会计', 5566, 2200, NULL, 10 ),
	( 3588, '朱九真', '会计', 5566, 2500, NULL, 10 );
-- 上面这段是一个人力资源管理系统的建库建表语句，下面是SQL练习题目

-- 查询月薪最高的员工姓名和工资
SELECT ename, sal FROM TbEmp
WHERE sal=(SELECT max(sal) FROM TbEmp);

-- SELECT ename, max(sal) FROM TbEmp;
-- or
select ename, sal from TbEmp
order by sal desc limit 1;
-- 查询员工的姓名和年薪((月薪+补贴)*13)
SELECT ename, if(comm, (sal+comm)*13, sal*13) FROM TbEmp;

-- teacher
select ename as 姓名, (sal+ifnull(comm, 0)) * 13 as 年薪 from TbEmp;
-- 查询有员工的部门编号和人数
SELECT dno, count(dno) from TbEmp
group by dno;
-- 查询所有部门的名称和人数
select dname, ifnull(total, 0) from TbDept
left outer join (SELECT dno, count(dno) as total from TbEmp
group by dno) temp
on TbDept.dno=temp.dno;

select dname, ifnull(total, 0)
from TbDept t1, (select dno, count(dno) as total from TbEmp
group by dno) t2
where t1.dno=t2.dno(+);
-- 查询薪资最高的员工(Boss除外)的姓名和工资
select ename, sal from TbEmp
where sal=(select max(sal) from TbEmp where mgr is null);
-- 查询薪水超过平均薪水的员工的姓名和工资
select ename, sal from TbEmp where sal>(select avg(sal) from TbEmp);
-- 查询薪水超过其所在部门平均薪水的员工的姓名、部门编号和工资
select ename, t1.dno, avgsal, sal-avgsal from TbEmp t1
inner join (select dno, avg(sal) as avgsal from TbEmp
group by dno) t2
on t1.dno=t2.dno and sal>avgsal;

select dno, max(sal) from TbEmp group by dno;
-- 查询部门中薪水最高的人姓名、工资和所在部门名称
select ename, sal, dname from TbEmp t1
inner join (select dno, max(sal) as maxsal
from TbEmp group by dno) temp
on t1.dno=temp.dno and sal=maxsal
inner join TbDept t2
on t1.dno=t2.dno;
-- 查询主管的姓名和职位
select ename, job from TbEmp
where eno in (select distinct mgr
from TbEmp where mgr is not null);

-- 尽量避免使用distinct和in/not in运算
-- 我们可以通过exists或者not exists来取代去重和集合运算
select ename, job from TbEmp t1
where exists (select 'x' from TbEmp t2 where t1.eno=t2.mgr);
-- 查询薪资排名4~6名的员工姓名和工资
-- 前三
select ename, sal from TbEmp
order by sal desc limit 3;
-- 4-6
select ename, sal from TbEmp
order by sal desc limit 3 offset 3;-- 跳过前3条查询后面的前3
-- 分页查询
select ename, sal from TbEmp
order by sal desc limit 3,3;-- 跳过3条查6条
-- 薪水 == 月薪 （不包括补贴）

-- 创建用户
create user 'hellokitty'@'%' identified by 'Lsmile870521...';
-- 授权
grant all privileges on *.* to 'hellokitty'@'%'; -- 授权所有数据库
grant all privileges on HRS.* to 'hellokitty'@'%'; -- 只授权HRS数据库权限
-- 召回权限
revoke insert, delete on HRS.* from 'helloketty'@'%';

```



###### nginx+uwsgi

[链接](https://github.com/coco369/knowledge/blob/master/%E9%83%A8%E7%BD%B2/centos%E9%83%A8%E7%BD%B2.md)



高等数学：自己百度

量化知识：百加自己文档

[量化策略](https://www.sohu.com/a/223499368_769402)

```
量化交易：
建立量化数据库的意义：
1、	建模：
模型建立
模型评估
模型回测
风险控制
2、	交易

数据的获取
http://tushare.org/index.html

存储方式
1、	csv
2、	NoSQL
3、	SQL

数据格式
1、	交易所信息
2、	数据来源
3、	价格
4、	企业行为
5、	国家假日（防止数据是空）


Tushare中的接口：
get_k_data() - 获取个股历史交易数据（包括均线数据），可以通过参数设置获取日k线、周k线、月k线，以及5分钟、15分钟、30分钟和60分钟k线数据。

get_hist_data() – 一次性获取全部日k线数据


说：
通过tushare拿到接口获取数据；
爬过新浪财经的股市评论和股市新闻；

```







##### 中软Python

装饰器

```Python
import time
def set_func(func):
    def call_func(*args, **kwargs):
        start_time = time.time()
        func(*args, **kwargs)
        end_time = time.time()
        print('use time:%i' % int(end_time - start_time))
    return call_func

@set_func
def test(a):
    time.sleep(3)
    print(a)

test('a')

```



Cookie与Session的区别
cookie数据存放在客户的浏览器上，session数据放在服务器上；
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；
Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，
上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，
而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用
（注意：有些资料说ASP解决这个问题，当浏览器的cookie被禁掉，服务端的session任然可以正常使用，ASP我没试验过，但是对于网络上很多用php和jsp编写的网站，
我发现禁掉cookie，网站的session都无法正常的访问）



同步和异步

同步：就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。  

异步调用就是你 喊 你朋友吃饭 ，你朋友说知道了 ，待会忙完去找你 ，你就去做别的了。 



一、python3和python2有什么区别？
python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。
python3里，print()是一个函数，像其他函数一样，print()需要你将要输出的东西作为参数传给它。

python２有两个全局函数可以把对象强制转换成字符串:unicode()把对象转换成unicode字符串，还有str()把对象转换为非Unicode字符串。
Python3只有一种字符串类型，unicode字符串，所以str()函数即可完成所有的功能。

python2有非浮点数准备的int和long类型。int类型最大值不能超过sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个Ｌ来定义长整型，
显然，它比int类型表示的数字范围更大。
在python3里，只有一种整数类型int,大多数情况下，和python２中的长整型类似。

Python2支持<>作为!=的同义词，　python3只支持!=, 不再支持<>

Python2中，字典对象has_key()方法测试字典是否包含指定的键。python3不再支持这个方法，需要使用in.

在python2里，许多字典类方法的返回值是列表。最常用方法有keys, items和values。python3，所有以上方法的返回值改为动态试图。
在一些上下文环境里，这种改变不会产生影响。如果这些方法的返回值被立即传递给另外一个函数，而且那个函数会遍历整个序列，
那么以上方法的返回值是列表或视图并不会产生什么不同。
如果你期望获得一个被独立寻址元素的列表，那么python3的这些改变将会使你的代码卡住，因为视图不支持索引。

从python2到python3，标准库里的一些模块已经被重命名。还有一些相互关联的模块也被组合或则重新组织，使得这种关联更有逻辑性。



三、进程之间是怎么进行通信的？
1.Queue使用方法：
Queue.qsize()：返回当前队列包含的消息数量；
Queue.empty()：如果队列为空，返回True，反之False ；
Queue.full()：如果队列满了，返回True,反之False；
Queue.get():获取队列中的一条消息，然后将其从列队中移除，可传参超时时长。
Queue.get_nowait()：相当Queue.get(False),取不到值时触发异常：Empty；
Queue.put():将一个值添加进数列，可传参超时时长。
Queue.put_nowait():相当于Queue.get(False),当队列满了时报错：Full。

自我介绍

- 性格 - 体现乐观向上的精神
- 学习能力，团队合作 - 体现综合素质
- 爱好 - 体现热爱编程





### 第二天

1. 字典里判断是否存在键？

   ```Python
   # 判断字典中是否含有某个键
   # 方法一
   def have_key(key, a_set):
       set_list = []
       for akey in a_set.keys():
           set_list.append(akey)
       if key in set_list:
           return a_set[key]
       else:
           return None
   
   # 方法二：python2.x中的has_key()
   ```

   

2. re模块、findall()返回的是啥？

   ```
   1、compile() - 返回正则表达式对象，作用是预编译
   在模式匹配发生之前，正则表达式模式必须编译 成正则表达式对象
   2、match() - 成功返回匹配对象，失败返回None
   3、search() - 成功返回匹配对象，失败返回None
   4、re.I - 忽略大小写
   5、re.S - 让'.'可以匹配换行符'\n'
   6、匹配对象的group()和groups()方法
   	group() - 返回整个匹配对象
   	group(num) - 返回特定子组
   	groups() - 返回一个包含所有匹配子组的元组（如果没有成功匹配，则返回一个空元组）
   7、findall() - 查找字符串中所有（非重复）出现的正则表达式模式，并返回一个匹配列表
   ```

   

3. list、dict常用操作？

   list

   | 方法                                  | 作用                                                         |
   | ------------------------------------- | ------------------------------------------------------------ |
   | lst.append(x)                         | 将元素x添加至列表lst的尾部                                   |
   | lst.extend(L)                         | 将列表L中的所有元素添加至列表lst尾部                         |
   | lst.insert(index, x)                  | 在列表lst指定位置index处添加元素x，该元素后面的所有元素后移一个位置 |
   | lst.remove(x)                         | 在列表lst中删除首次出现的指定元素，该元素之后的所有元素前移一个位置 |
   | lst.pop([index])                      | 删除并返回列表lst中下标为index（默认为-1，即列表尾部）的元素 |
   | lst.clear()                           | 删除列表lst中的所有元素，但保留列表对象                      |
   | lst.index(x)                          | 返回列表lst中第一个值为x的元素的下标，若不存在值为x的元素则抛出异常 |
   | lst.count(x)                          | 返回指定元素x在列表lst中的出现次数                           |
   | lst.reverse()                         | 将列表lst所有元素进行逆序                                    |
   | lst.sort(key = None, reverse = False) | 对列表lst中的元素进行排序，key用来指定排序依据，reverse决定升序（False）还是降序（True） |
   | lst.copy()                            | 返回列表lst的浅复制                                          |

   dict

   | 字典操作                  | 描述                                                         |
   | ------------------------- | ------------------------------------------------------------ |
   | dic.clear()               | 清空字典                                                     |
   | dic.copy()                | 赋值字典                                                     |
   | dic.get(k, [default])     | 获得键k对应的值，不存在则返回default                         |
   | dic.items()               | 获得由键和值组成的迭代器                                     |
   | dic.keys()                | 获得键的迭代器                                               |
   | dic.pop(k)                | 删除k:v键值对                                                |
   | dic.update(adict)         | 从另一个字典更新成员（不存在就创建，存在就覆盖）             |
   | dic.values()              | 获得值的迭代器                                               |
   | dic.fromkeys(iter, value) | 以列表或元祖中给定的键建立字典，默认值为value                |
   | dic.popitem()             | 从字典中删除一k:v项并返回它                                  |
   | dic.setdefault(k,default) | 若字典中存在key值为k的，则返回其对应的值；否则在字典中建立一个k:default字典成员 |

   

4. 函数

   - 高阶函数 - 函数作为参数传给函数

     ```Python
     def func1(x, y):
         return x + y
     
     def func2(x, y, f):
         return f(x, y)
     
     result = func2(3, 4, func1)
     print(result)
     ```

   - map(fun, iter) - 将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表返回 

     ```Python
     f = lambda x: x + 1
     a = (1, 4, 6)
     print(map(f, a))
     print(type(map(f, a)))
     for i in map(f, a):
         print(i)
     print(a)
         
     '''
     <map object at 0x0000026B440043C8>
     <class 'map'>
     2
     5
     7
     (1, 4, 6)
     '''
     ```

   - reduce（func（x,y），iter），其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。 

     ```Python
     from functools import reduce
     
     f = lambda x, y: x + y
     a = (1, 4, 6, 2)
     print(reduce(f, a))
     
     ```

     

5. 用numpy、pandas具体做了啥？

   ```
   numpy
   array - 创建数组
   pandas
   DataFrame、series
   ```

   

6. list? set? dict?

   ```
   list相当于c中的数组
   ```

   - [字典中的键是不可变的](https://www.jianshu.com/p/56691574ef9e)

   - 快速合并两个字典：

     ```Python
     import copy
     def merge_two_dicts(x, y):
         z = x.copy()
         z.update(y)
         return z
     
     x = {'a': 1}
     y = {'b': 2}
     
     print(merge_two_dicts(x, y))
     print(x)
     '''
     {'a': 1, 'b': 2}
     {'a': 1}
     '''
     ```

   - [深浅拷贝](https://blog.csdn.net/jimmy_gyn/article/details/79133361?utm_source=blogxgwz1)

     通过把一个列表变量名赋值给另一个变量名,只是把一个列表变量名list1的指引赋值给另一个变量名list2,使list1和list2都指向[1,2,3],所以当列表中的一个元素改变了,list1和list2都变了. 

     ```Python
     list1 = [1, 2]
     list2 = list1
     print(id(list1), id(list2))
     list1[0] = 9
     print(list1, list2)
     '''
     3143573528328 3143573528328
     [9, 2] [9, 2]
     '''
     ```

     

   

7. socket模块？

8. 自动化测试

9. python设计模式[链接](https://blog.csdn.net/zheng_lan_fang/article/details/76550093?utm_source=blogxgwz1)

   - 工厂设计模式

     定义了一个创建对象的接口，但由子类决定要实例化类的哪一个；即通过子类来创建对象。 

     适用性：

     当一个类不知道它所必须创建的对象的类的时候。

     当一个类希望由它的子类来指定它所创建的对象的时候。

     当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

   - 单例模式

     意图：

     保证一个类仅有一个实例，并提供一个访问它的全局访问点。

     适用性：

     当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。

     当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

   - 装饰

     意图： 
     动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 
     适用性：

      在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

10. 列表、字典、集合推导式

   ```Python
   # 列表推导式
   a_list = [a * 2 for a in range(10)]
   
   # 集合推导式
   a_set = {a for a in range(10)}
   
   # 字典推导式
   # enumerate() - 分别得到元素的序号和该元素
   a_dict = {key: value for key, value in enumerate(reversed(range(10)))}
   
   ```

11. 字符串常用函数

    find() -  返回字符串第一个匹配项出现在字符串中的索引位置，如果没有匹配项则返回-1。

    index() - 返回字符串第一个匹配项出现在字符串中的索引位置，如果没有匹配项则抛出异常的。

    count() - 统计子字符串在父字符串中出现的次数，不存在返回0。

    **split() - 拆分字符串。通过指定分隔符对字符串进行切片。返回列表**

    **join() - 用于将可迭代对象中的元素以指定的字符连接生成一个新的字符串。**

    **strip() - 用于删除字符串头部和尾部指定的字符，默认字符为所有空字符，包括空格、换行(\n)、制表符(\t)等。 如果头尾不存在要删除的字符（串），则返回原字符（串）**

    swapcase() - 对字符串的大小写字母进行转换.

    

    

    ### 冒泡排序

    https://gitee.com/lsmilesmile/CD1803

    ### 快速排序

    

    切片

    | 使用形式     | 意义                                 |
    | ------------ | ------------------------------------ |
    | alst[:]      | 取全部成员数据项                     |
    | alst[0:]     | 取全部成员数据项                     |
    | alst[:-1]    | 取除最后一个成员之外的所有成员数据项 |
    | alst[2:5]    | 开始位置2，结束位置5                 |
    | alst[::2]    | 从0到整个长度，步长是2               |
    | alst[0:5:2]  | 从0到5，步长是2                      |
    | alst[::-1]   | 从右向左取全部成员                   |
    | alst[5:0:-2] | 从右到左隔一个取一个值               |

    ```Python
    a_list = [1, 2, 3, 4, 5, 7]
    print(a_list[:1])  # 取第一个元素
    print(a_list[-1:])  # 取最后一个元素
    print(a_list[:2])  # 取前两个元素
    print(a_list[-2:])  # 取后两个元素
    print(a_list[-4:-1:2])
    '''
    [1]
    [7]
    [1, 2]
    [5, 7]
    [3, 5]
    '''
    ```

    

12. # 云打码

    [云打码](http://www.cnblogs.com/TM0831/p/9747207.html)

    

    

    ###### [反爬](https://www.cnblogs.com/junrong624/p/5533655.html)：

    1、User-Agent：自己定制UA，设置用户代理池；
    2、ajax请求 - 分析ajax请求的url；
    3、动态渲染你的页面：selenium+PhantomJS
    4、封ip解决：使用ip代理池
        两种类型的代理：
        （1）、提供接口获取海量代理；- 讯代理
        （2）、搭建代理隧道，直接设置固定域名代理。- 阿布云代理
    5、js加密
        （1）、[例子](https://blog.csdn.net/lsh19950928/article/details/81585881)
    6、限制访问频率 - 设置睡眠时间，需要登录的网站最好登录
    7、验证码 - 打马平台（云打马，超级鹰）

    

    ###### [聚焦爬虫和通用爬虫](https://www.cnblogs.com/zxf123/p/9061532.html)

    

    

    

    

    

    

    

    

    

    

    